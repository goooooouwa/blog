<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13 (455674)"/><meta name="author" content="Greg Xu"/><meta name="created" content="2011-12-15 12:39:50 +0000"/><meta name="updated" content="2013-05-04 05:35:29 +0000"/><title>对 scanf 函数的新认识的更正：其实什么也没发现</title></head><body><div>底下的一篇文章是我在捣鼓《编程珠玑》“变位词程序的实现”中三个小程序时发现的现象。这个发现是错误的。其实 sign 程序可以自动读取文件作为输入与其本身毫无关系，只是 shell "&lt;" IO重定向的作用罢了。</div>
<div>因为 shell IO重定向，将 newfile 重定向为标准输入文件，对于 scanf 函数（从标准输入读取内容），它就当然是键盘输入了。</div>
<div>其实什么也没发现。我还是不知道 Linux 命令行工具读取命令参数的原理。</div>
<div><br clear="none"/></div>
<div>附上原文：</div>
<div style="margin-left: 30px;"><em>发现：scanf 函数可以自动检测是否有文件作为输入</em></div>
<div style="margin-left: 30px;">我在Linux shell环境下发现：</div>
<div style="margin-left: 30px;">如果你编写一个包含 scanf 函数的程序，它就会在运行时自动检查是否有文件作为输入，若是以文件作为输入，则它会直接从文件中读取数据，而不再是用户键盘。</div>
<div style="margin-left: 30px;"/>
<div style="margin-left: 30px;">比如，程序sign的代码如下：</div>
<div style="margin-left: 30px;">
<p style="margin-left: 30px;"><span style="color: #008000; font-family: 'courier new', courier; font-size: small;">#include &lt;stdio.h&gt;</span></p>
<p style="margin-left: 30px;"><span style="color: #008000; font-family: 'courier new', courier; font-size: small;">int main()</span></p>
<p style="margin-left: 30px;"><span style="color: #008000; font-family: 'courier new', courier; font-size: small;">{</span></p>
<p style="margin-left: 60px;"><span style="color: #008000; font-family: 'courier new', courier; font-size: small;"> char word[20];</span><br clear="none"/><span style="color: #008000; font-family: 'courier new', courier; font-size: small;">scanf("%s", word);</span><br clear="none"/><span style="color: #008000; font-family: 'courier new', courier; font-size: small;">printf("%s \n", word);</span><br clear="none"/><span style="color: #008000; font-family: 'courier new', courier; font-size: small;"> return 0;</span></p>
<p style="margin-left: 30px;"><span style="color: #008000; font-family: 'courier new', courier; font-size: small;">}</span></p>
</div>
<div style="margin-left: 30px;">如果你运行</div>
<div style="margin-left: 60px;"><span style="font-family: 'courier new', courier; font-size: small; color: #008000;">$ ./sign &lt;newfile</span></div>
<div style="margin-left: 30px;">程序就会直接读取newfile里面的数据，而非键盘输入。并且，因为本程序每次运行读取一个字符串（<span style="font-family: 'courier new', courier; font-size: small; color: #008000;">scanf("%s", word);</span>），shell环境下还会自动重复运行该程序，每次读入一个字符串，直到到达文件末尾为止。</div>
<div style="margin-left: 30px;">这种现象的发生应该是 scanf 函数在 Linux 环境下的具体实现的缘故吧。</div>
<div style="margin-left: 30px;"/>
<div style="margin-left: 30px;">附上函数签名：</div>
<div style="margin-left: 30px;">
<div>
<h1>scanf</h1>
<div>function</div>
</div>
<div>
<div><code>&lt;cstdio&gt;</code></div>
<div>
<pre xml:space="preserve">int  scanf ( const char * format, ... );</pre>
</div>
</div>
<p><strong>Read formatted data from stdin</strong></p>
Reads data from <tt>stdin</tt> and stores them according to the parameter <em>format</em> into the locations pointed by the additional arguments. The additional arguments should point to already allocated objects of the type specified by their corresponding format tag within the <em>format</em> string.</div></body></html>